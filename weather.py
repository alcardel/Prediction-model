# -*- coding: utf-8 -*-
"""Prediction of mars environment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GpUtBzFBKk-IJgBTLszz8CUe1Ral1yuX
"""

import pandas as pd

# Load the data
mars_weather = pd.read_csv("/content/REMS_Mars_Dataset.csv")

# Look at the data
print(mars_weather.head())

mars_weather = mars_weather.rename(columns={
    'earth_date_time': 'earth_date',
    'sol_number': 'sol',
    'max_ground_temp(°C)': 'max_ground_temp',
    'min_ground_temp(°C)': 'min_ground_temp',
    'max_air_temp(°C)': 'max_air_temp',
    'min_air_temp(°C)': 'min_air_temp',
    'mean_pressure(Pa)': 'mean_pressure',
    'wind_speed(m/h)': 'wind_speed',
    'humidity(%)': 'humidity',
    'UV_Radiation': 'uv_radiation'
})

mars_weather.head()

columns_to_drop = ['wind_speed', 'humidity', 'uv_radiation', 'weather']
mars_weather = mars_weather.drop(columns=columns_to_drop)

mars_weather

# Perform column transformations
mars_weather['earth_date'] = mars_weather['earth_date'].str.replace("Earth, | UTC", "")
mars_weather['sol'] = mars_weather['sol'].str.replace("Sol ", "")
mars_weather['mars_date_time'] = mars_weather['mars_date_time'].str.replace("°", "")

# Look at the updated DataFrame
print(mars_weather.head())

# Look at the updated DataFrame
print(mars_weather.head())

# Create new column for day duration
mars_weather['day_duration'] = pd.to_datetime(mars_weather['sunset']) - pd.to_datetime(mars_weather['sunrise'])
mars_weather['day_duration'] = mars_weather['day_duration'].dt.total_seconds() / 60

# Look at the updated DataFrame
print(mars_weather.head())

# Calculate average ground temperature
mars_weather['mean_ground_temp'] = mars_weather[['max_ground_temp', 'min_ground_temp']].mean(axis=1, skipna=True)

# Calculate average air temperature
mars_weather['mean_air_temp'] = mars_weather[['max_air_temp', 'min_air_temp']].mean(axis=1, skipna=True)

# Look at the updated DataFrame
print(mars_weather.head())

# Extract solar longitude from mars_date_time
mars_weather['solar_long'] = mars_weather['mars_date_time'].str[-3:]
mars_weather['solar_long'] = mars_weather['solar_long'].str.replace("S | ", "")
mars_weather['solar_long'] = pd.to_numeric(mars_weather['solar_long'])

# Look at the updated DataFrame
print(mars_weather.head())

# Define a function to determine the season based on solar longitude
def get_season(solar_long):
    if 0 <= solar_long <= 89:
        return 'Spring'
    elif 90 <= solar_long <= 179:
        return 'Summer'
    elif 180 <= solar_long <= 269:
        return 'Autumn'
    elif 270 <= solar_long <= 360:
        return 'Winter'
    else:
        return 'Unknown'

# Create a new 'season' column using the function
mars_weather['season'] = mars_weather['solar_long'].apply(get_season)

# Look at the updated DataFrame
print(mars_weather.head())

# Convert 'season' column to a categorical data type with specified order of levels
mars_weather['season'] = pd.Categorical(mars_weather['season'], categories=['Spring', 'Summer', 'Autumn', 'Winter'], ordered=True)
# Look at the updated DataFrame
print(mars_weather.head())

# Convert 'sol' column to numeric data type
mars_weather['sol'] = pd.to_numeric(mars_weather['sol'], errors='coerce')

# Define the conditions and choices for years
conditions = [
    (mars_weather['sol'].between(0, 350)),
    (mars_weather['sol'].between(351, 1018)),
    (mars_weather['sol'].between(1019, 1687)),
    (mars_weather['sol'].between(1688, 2356)),
    (mars_weather['sol'].between(2357, 3023)),
    (mars_weather['sol'].between(3024, 3368))
]
choices = ['Year 31', 'Year 32', 'Year 33', 'Year 34', 'Year 35', 'Year 36']

import numpy as np

# Create a new 'mars_year' column based on the conditions and choices
mars_weather['mars_year'] = np.select(conditions, choices, default='Unknown')

# Look at the updated DataFrame
print(mars_weather.head())

# Write the cleaned DataFrame to CSV
mars_weather.to_csv("mars_weather_clean.csv", index= True)

import pandas as pd

# Read the CSV file
mars_season = pd.read_csv("/content/mars_weather_clean.csv")

# Filter the data based on 'mars_year' column
mars_season = mars_season[(mars_season['mars_year'] != "Year 31") & (mars_season['mars_year'] != "Year 36")]

# Display the first few rows
print(mars_season.head())

import matplotlib.pyplot as plt

# Set the plot size
plt.figure(figsize=(13, 6.5))

# Convert 'season' column to categorical data type
mars_season['season'] = pd.Categorical(mars_season['season'], categories=['Spring', 'Summer', 'Autumn', 'Winter'])

# Convert 'season' column to categorical data type
mars_season['season'] = pd.Categorical(mars_season['season'], categories=['Spring', 'Summer', 'Autumn', 'Winter'])

# Assign numeric codes to 'season' categories
mars_season['season_code'] = mars_season['season'].cat.codes

# Plot the daylight variation
plt.scatter(mars_season['sol'], mars_season['day_duration'], c=mars_season['season_code'], cmap='Set1')
plt.title('Daylight variation during seasons in the years 32-35')
plt.xlabel('Sol number (days in Mars)')
plt.ylabel('Daylight (minutes)')

"""The shortest days occur in late Spring and the days with the most sunlight occur in late Autumn."""

# Set the plot size
plt.figure(figsize=(8, 6))

mars_season

# Calculate the average daylight duration by season and year
avg_daylight = mars_season.groupby(['mars_year', 'season']).agg(avg_day=('day_duration', 'mean')).reset_index()

# Pivot the data to create a matrix for the heatmap
heatmap_data = avg_daylight.pivot('mars_year', 'season', 'avg_day')

# Create the heatmap
plt.imshow(heatmap_data, cmap='YlGnBu')

# Set x-axis and y-axis labels
plt.xlabel('Season')
plt.ylabel('Mars year')

# Set the colorbar
plt.colorbar(label='Average daylight time')

# Add value annotations to each cell
for i in range(len(heatmap_data)):
    for j in range(len(heatmap_data.columns)):
        plt.text(j, i, f'{heatmap_data.iloc[i, j]:.0f}', ha='center', va='center', color='black')

# Set the title
plt.title('Average daylight time by season and year')

# Show the heatmap
plt.show()

"""The average length of days remains constant throughout the Mars years. Spring and Summer have shorteer days while Autumn and Winter have longest."""

# Set the plot size
plt.figure(figsize=(6, 6))

mars_season

import re
import numpy as np
import matplotlib.pyplot as plt

# Convert 'mars_year' values to strings
mars_season['mars_year'] = mars_season['mars_year'].astype(str)

# Extract the numeric part from 'mars_year' column
mars_season['mars_year'] = mars_season['mars_year'].apply(lambda x: int(re.search(r'\d+', x).group()))

# Convert 'mean_pressure' values to float, replacing non-numeric values with NaN
mars_season['mean_pressure'] = pd.to_numeric(mars_season['mean_pressure'], errors='coerce')

# Plot the data
plt.scatter(mars_season['solar_long'], mars_season['mean_pressure'], c=mars_season['mars_year'], alpha=0.7, cmap='viridis', edgecolors='none')

plt.colorbar(label='Mars Year')
plt.title('Variation of atmospheric pressure across the years')
plt.xlabel('Solar Longitude (Ls)')
plt.ylabel('Pressure (Pascal)')
plt.show()

"""There is a strange phenomenon where the atmospheric pressures are lower every year, maybe there is a calibration problem in the rover's measuring instrument."""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Convert temperature columns to numeric type
mars_season['max_ground_temp'] = pd.to_numeric(mars_season['max_ground_temp'], errors='coerce')
mars_season['min_ground_temp'] = pd.to_numeric(mars_season['min_ground_temp'], errors='coerce')

# Calculate the average ground temperature
mars_season['avg_ground_temp'] = (mars_season['max_ground_temp'] + mars_season['min_ground_temp']) / 2

# Drop rows with missing values
mars_season_filtered = mars_season.dropna(subset=['max_ground_temp', 'min_ground_temp', 'avg_ground_temp'])

# Set plot size
plt.figure(figsize=(9, 6))

# Scatter plot of max and min ground temperature
sns.scatterplot(data=mars_season_filtered, x='solar_long', y='max_ground_temp', hue='season', alpha=0.5)
sns.scatterplot(data=mars_season_filtered, x='solar_long', y='min_ground_temp', hue='season', alpha=0.5)

# Plot the average ground temperature
sns.lineplot(data=mars_season_filtered, x='solar_long', y='avg_ground_temp', color='black')

# Set plot title and labels
plt.title('Ground Temperature: Minimum, Maximum, and Average')
plt.xlabel('Solar Longitude (Ls)')
plt.ylabel('Ground Temperature (C°)')

# Show the plot
plt.show()

import seaborn as sns
sns.heatmap(mars_season.corr(), annot=False, cmap='coolwarm')

# Set the title
plt.title('Correlation Heatmap')

# Show the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Set plot size
plt.figure(figsize=(9, 6))
# Convert temperature columns to numeric type
mars_season['max_ground_temp'] = pd.to_numeric(mars_season['max_ground_temp'], errors='coerce')
mars_season['min_ground_temp'] = pd.to_numeric(mars_season['min_ground_temp'], errors='coerce')

# Calculate the average ground temperature
mars_season['mean_ground_temp'] = (mars_season['max_ground_temp'] + mars_season['min_ground_temp']) / 2

# Drop rows with missing values
mars_season_filtered = mars_season.dropna(subset=['max_ground_temp', 'min_ground_temp', 'avg_ground_temp'])

# Convert air columns to numeric type
mars_season['max_air_temp'] = pd.to_numeric(mars_season['max_air_temp'], errors='coerce')
mars_season['min_air_temp'] = pd.to_numeric(mars_season['min_air_temp'], errors='coerce')

# Calculate the average ground temperature
mars_season['mean_air_temp'] = (mars_season['max_air_temp'] + mars_season['min_air_temp']) / 2

# Drop rows with missing values
mars_season_filtered = mars_season.dropna(subset=['max_ground_temp', 'min_ground_temp', 'avg_ground_temp'])

# Scatter plot of mean air temperature and mean ground temperature
sns.scatterplot(data=mars_season_filtered, x='solar_long', y='mean_air_temp',  color="skyblue",alpha=0.3)
sns.scatterplot(data=mars_season_filtered, x='solar_long', y='mean_ground_temp', color="chocolate", alpha=0.3)

# Plot the trend line for mean air temperature
sns.lineplot(data=mars_season_filtered, x='solar_long',color="red", y='mean_air_temp')

# Plot the trend line for mean ground temperature
sns.lineplot(data=mars_season.dropna(), x='solar_long', color="black", y='mean_ground_temp')

# Set plot title and labels
plt.title('Ground Temperature vs Air Temperature Records')
plt.xlabel('Solar Longitude (Ls)')
plt.ylabel('Temperature (C°)')

# Show the plot
plt.show()

from sklearn.metrics import mean_squared_error, mean_absolute_error

# Assuming you have loaded the Mars season dataset into a DataFrame called 'mars_season'
# And you have preprocessed the data and created 'mean_ground_temp' and 'mean_air_temp' columns as the target variables

# Drop rows with missing values
mars_season_filtered = mars_season.dropna(subset=['mean_ground_temp', 'mean_air_temp'])

# Calculate MSE
mse = mean_squared_error(mars_season_filtered['mean_ground_temp'], mars_season_filtered['mean_air_temp'])
print('Mean Squared Error (MSE):', mse)

# Calculate MAE
mae = mean_absolute_error(mars_season_filtered['mean_ground_temp'], mars_season_filtered['mean_air_temp'])
print('Mean Absolute Error (MAE):', mae)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score


# Select the feature columns
X = mars_season[['max_ground_temp', 'max_air_temp']]

# Select the target variable
y = mars_season['season']

# Drop rows with missing values
mars_season_filtered = mars_season.dropna(subset=['max_ground_temp', 'max_air_temp'])
X_filtered = mars_season_filtered[['max_ground_temp', 'max_air_temp']]
y_filtered = mars_season_filtered['season']

# Split the filtered dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_filtered, y_filtered, test_size=0.2, random_state=42)

# Create a K-nearest neighbors classifier
knn = KNeighborsClassifier(n_neighbors=5)

# Train the classifier on the training data
knn.fit(X_train, y_train)

# Make predictions on the testing data
y_pred = knn.predict(X_test)

# Calculate the accuracy of the model
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)